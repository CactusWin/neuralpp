import math
from collections import deque
from typing import Dict, Type, Callable, List, Iterable, Optional, Set

from neuralpp.inference.graphical_model.representation.factor.factor import Factor
from neuralpp.inference.graphical_model.variable.variable import Variable
from neuralpp.util import util
from neuralpp.util.util import empty


class FactorMaker:
    """
    An object that knows how to make a factor based on a tuple of variables of particular types.
    It is assumed that the first variable is always the child if the factor is to be considered
    a conditional probability.
    """

    def __init__(self, variable_types: List[Type], make: Callable[[List[Variable]], Factor]):
        """
        Initializes a FactorMaker with a function for making a factor given its variables,
        and a tuple of the variable types (first variable is assumed to be the child if the factor
        is to be considered a conditional probability.
        """
        self.make = make
        self.variable_types = variable_types

    def __call__(self, variables: List[Variable]):
        """
        A shortcut for self.make(variables)
        """
        return self.make(variables)

    @property
    def child_type(self) -> Type:
        return self.variable_types[0]

    @property
    def parent_types(self) -> List[Type]:
        return self.variable_types[1:]


class MultiTypeRandomModel:
    """
    A random model involving multiple customizable types of variables and factors.
    """

    def __init__(self,
                 threshold_number_of_variables_to_generate: int,
                 from_type_to_number_of_seed_variables: Dict[Type, int],
                 variable_maker: Callable[[Type, str], Variable],
                 factor_makers: List[FactorMaker],
                 loop_coefficient: int = 0.5,
                 ):
        """
        Generates a random model based on given specifications.
        
        The method works by generating an initial set of variables without descendants (leaves).
        Variables are generated by a "variable maker" function that makes a variable of a given type and name.
        Initially these seed variables don't have an associated distribution.
        
        The main loop of the method then keeping picking some variable without a distribution (the "child")
        and generates a distribution for it by using user-provided "factor makers".
        These distributions require parent variables.
        If the model still needs to grow (the threshold number of variables has not been reached yet),
        then an initial percentage of them (a user-defined "loop coefficient") will be newly-made variables,
        while the remaining ones are selected from pre-existing variables if possible.
        By "possible", we mean that the pre-existing variable can only be a parent of the child
        if it is of the right type and it is not a descendant of the child (to avoid the creation of directed cycles).
        If no pre-existing variable is allowed to be a parent of child, a new one is created.

        New variables are placed in a FIFO queue for receiving a distribution, so the graph is formed in
        a breadth-first way.
        
        When the target number of variables is equalled or exceeded, we
        only create new variables if absolutely necessary in order to provide a parent of the right type,
        and all new distributions created from then on are parentless.
        This causes the model generation to be completed.
        
        Parameters:
            threshold_number_of_variables_to_generate.

            from_type_to_number_of_seed_variables: a dict mapping a type to the number of required seed variables
            of that type in the model. Seed variables are the leaves of the graphical model and have no descendants.

            variable_maker: a callable making a new variable of a given type and name (string).

            factor_makers: a list of FactorMakers to be used when adding factors to the model.

            loop_coefficient: a number from 0 to 1 reflecting how hard we should try to create loops.

        The generated model is available at self.from_variable_to_distribution after initialization.
        This is a dict mapping each variable to its corresponding distribution (a Factor).
        """

        # Attributes initialized by parameter
        self.threshold_number_of_variables_to_generate = threshold_number_of_variables_to_generate
        self.from_type_to_number_of_seed_variables = from_type_to_number_of_seed_variables
        self.variable_maker = variable_maker
        self.factor_makers = factor_makers
        self.loop_coefficient = loop_coefficient

        # Attribute initialization
        self.from_variable_to_distribution: Dict[Variable, Factor] = {}
        self._queue_of_variables_without_distribution = deque()
        self._from_variable_to_descendants: Dict[Variable, Set[Variable]] = {}
        self.there_is_a_child_being_processed = False  # See number_of_variables_generated_so_far for explanation

        # Model generation
        self.make_seed_variables()
        self.complete_model_generation()

    def make_seed_variables(self):
        for type, number_of_variables_of_type in self.from_type_to_number_of_seed_variables.items():
            util.repeat(number_of_variables_of_type, lambda: self.make_new_variable(type, child=None))

    def complete_model_generation(self):
        while not empty(self._queue_of_variables_without_distribution):
            next_variable_to_get_a_distribution = self.get_next_variable_without_distribution_to_process()
            self.register_distribution_for(next_variable_to_get_a_distribution)

    def get_next_variable_without_distribution_to_process(self):
        next_variable_to_get_a_distribution = self._queue_of_variables_without_distribution.popleft()
        self.there_is_a_child_being_processed = True
        return next_variable_to_get_a_distribution

    def register_distribution_for(self, variable: Variable):
        distribution = self.make_distribution_for(variable)
        self.from_variable_to_distribution[variable] = distribution
        self.there_is_a_child_being_processed = False

    def make_distribution_for(self, variable: Variable) -> Factor:
        if self.number_of_variables_generated_so_far >= self.threshold_number_of_variables_to_generate:
            return self.make_terminal_distribution_for(variable)
        else:
            return self.make_non_terminal_distribution_for(variable)

    def make_non_terminal_distribution_for(self, child: Variable) -> Factor:
        factor_maker = self.get_factor_maker_with_at_least_one_parent_for_child(child)
        parents = self.get_parents_for(child, factor_maker.parent_types)
        variables = [child, *parents]
        factor = factor_maker(variables)
        return factor

    def get_parents_for(self, child: Variable, types_of_parents: List[Type]) -> List[Variable]:
        # When obtaining parents for child, we dedicate a number of the initial ones to new variables
        # (so the model keeps growing if needed)
        # and the remaining as pre-existing ("old" for short) variables if possible (otherwise
        # we would always use new variables and never get cycles).
        # If no old variable of the right type exist, a new variable is made and used instead.

        new_variable_parents = self.get_new_variable_parents(child, types_of_parents)

        index_of_first_remaining_parent = len(new_variable_parents)
        types_of_remaining_parents = types_of_parents[index_of_first_remaining_parent:]
        remaining_parents = self.get_remaining_parents(child, types_of_remaining_parents)

        parents = [*new_variable_parents, *remaining_parents]
        return parents

    def get_new_variable_parents(self, child: Variable, types_of_parents) -> List[Variable]:
        number_of_new_variable_parents = \
            min(self.number_of_variables_that_still_need_to_be_generated,
                self.get_max_number_of_new_variable_parents(types_of_parents))
        new_variable_parents = [self.make_new_variable(parent_type, child)
                                for parent_type in types_of_parents[:number_of_new_variable_parents]]
        return new_variable_parents

    def get_max_number_of_new_variable_parents(self, types_of_parents: List[Type]):
        number_of_parents = len(types_of_parents)
        max_number_of_new_variables = math.ceil(number_of_parents * (1 - self.loop_coefficient))
        return max_number_of_new_variables

    def get_remaining_parents(self, child: Variable, types_for_old_variable_parents: List[Type]):
        attempted_old_variable_parents = \
            self.get_attempted_old_variable_parents(child, types_for_old_variable_parents)
        remaining_parents = [self.use_parent_or_make_new_one_if_none(attempted, parent_type, child)
                             for attempted, parent_type in
                             zip(attempted_old_variable_parents, types_for_old_variable_parents)]
        return remaining_parents

    def use_parent_or_make_new_one_if_none(self, parent: Variable, type: Type, child: Variable) -> Variable:
        return parent if parent is not None else self.make_new_variable(type, child)

    def get_attempted_old_variable_parents(
            self, 
            child: Variable, 
            types_for_attempted_old_variable_parents: List[Type])\
            -> List[Variable]:
        old_variable_parent_candidates_provider = \
            lambda: [v for v in self.variables_generated_so_far if self.is_not_descendant_of(v, child)]
        conditions_for_old_variable_parents = [
            lambda v: type(v) == parent_type
            for parent_type in types_for_attempted_old_variable_parents
        ]
        attempted_old_variable_parents = \
            util.choose_elements_without_replacement(old_variable_parent_candidates_provider,
                                                     conditions_for_old_variable_parents)
        return attempted_old_variable_parents

    def make_terminal_distribution_for(self, variable: Variable) -> Factor:
        factor_maker = self.get_factor_maker_with_no_parents_for(variable)
        factor = factor_maker.make([variable])
        return factor

    def get_factor_maker_with_at_least_one_parent_for_child(self, child: Variable) -> FactorMaker:
        factor_maker = \
            self.get_factor_maker_for_child_and_condition(
                child,
                lambda fm: len(fm.variable_types) > 1)
        if factor_maker is None:
            raise RuntimeError(f"Cannot find maker for factor with child of type {type(child)} and at least one parent")
        return factor_maker

    def get_factor_maker_with_no_parents_for(self, child: Variable) -> FactorMaker:
        factor_maker = \
            self.get_factor_maker_for_child_and_condition(
                child,
                lambda fm: len(fm.variable_types) == 1)
        if factor_maker is None:
            raise RuntimeError(f"Cannot find maker for factor with child of type {type(child)} and no parents")
        return factor_maker

    def get_factor_maker_for_child_and_condition(
            self,
            child: Variable,
            condition: Callable[[FactorMaker], bool]) -> FactorMaker:
        factor_maker = \
            util.find(
                self.factor_makers,
                lambda fm: fm.child_type == type(child) and condition(fm))
        return factor_maker

    # Basic methods and properties

    def make_new_variable(self, type: Type, child: Optional[Variable]) -> Variable:
        variable_name = f"x{self.number_of_variables_generated_so_far + 1}"
        new_variable = self.variable_maker(type, variable_name)
        self._queue_of_variables_without_distribution.append(new_variable)
        if child is None:
            descendants = {}
        else:
            descendants = {child}.union(self._from_variable_to_descendants[child])
        self._from_variable_to_descendants[new_variable] = descendants
        return new_variable

    def is_not_descendant_of(self, variable1: Variable, variable2: Variable) -> bool:
        return variable1 not in self._from_variable_to_descendants[variable2]

    @property
    def variables_generated_so_far(self) -> Iterable[Variable]:
        return self.from_variable_to_distribution.keys()

    @property
    def number_of_variables_generated_so_far(self) -> int:
        return \
            len(self.from_variable_to_distribution) + \
            len(self._queue_of_variables_without_distribution) + \
            (1 if self.there_is_a_child_being_processed else 0)

    @property
    def number_of_variables_that_still_need_to_be_generated(self) -> int:
        return self.threshold_number_of_variables_to_generate - self.number_of_variables_generated_so_far
